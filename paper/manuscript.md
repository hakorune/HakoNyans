# HakoNyans: 並列デコードを主軸とした画像コーデック設計と実装評価

## 概要（Abstract）

本稿では、並列デコード性能を第一目的として設計した画像コーデック HakoNyans を示す。提案方式は、NyANS-P に基づく軽量なエントロピー復号を核とし、lossless 経路では Copy/Palette/Filter/MED/TileMatch4 のブロック適応選択、lossy 経路では量子化制御と帯域分割 CDF により圧縮効率を改善する。評価では、(1) 視覚的比較（Anime/UI/Photo 各1枚）と (2) 定量比較（各カテゴリ合計30枚以上）を分離し、PNG/JPEG/WebP 等との比較を行う。結果として、デコード速度優位を維持しつつ、コンテンツ依存で圧縮率を改善できることを示す。

## 1. はじめに

画像コーデックの実運用では、圧縮率だけでなくデコード遅延が UX を大きく左右する。特にリモート表示、ゲームアセット展開、UI レンダリング補助では、復号の予測可能性と低遅延性が重要である。  
既存方式（PNG/JPEG/WebP/JPEG XL）はそれぞれ強みを持つ一方、用途によっては「高速デコードと圧縮効率のバランス」が課題となる。

HakoNyans はこの課題に対し、以下の方針を取る。

1. デコード経路を単純化し、並列化しやすい構造を優先する。
2. 圧縮率改善は主にエンコーダ側ヒューリスティクスで実現する。
3. 互換性と再現性を確保し、段階的に改善を積み上げる。

本稿の主な貢献は次の3点である。

1. NyANS-P を中心とした高速復号アーキテクチャの実装。
2. lossless モード決定（Copy/Palette/Filter/MED/TileMatch4）の段階的最適化。
3. 定性3枚 + 定量30枚以上の二層評価プロトコルの提示。

## 2. 手法の全体像

### 2.1 コンテナと処理フロー

HakoNyans は固定ヘッダ + チャンク構造を持ち、画像をタイル/ブロック単位で処理する。  
lossy/lossless はヘッダフラグで識別し、同一デコーダ内で経路を分岐する。

処理フローは次の通り。

1. Encode: Colorspace変換 -> ブロック解析 -> モード選択 -> NyANS-P符号化
2. Decode: チャンク復号 -> モード別再構成 -> Colorspace逆変換

### 2.2 エントロピー符号化

エントロピー層は NyANS-P を採用し、並列デコードを前提に設計する。  
帯域分割 CDF（Band-group CDF）を導入し、特に lossy AC 係数の分布差を活用する。

### 2.3 lossless モード

lossless 経路では 8x8 ブロック単位で以下を選択する。

1. `COPY`
2. `PALETTE`
3. `FILTER`（None/Sub/Up/Average/Paeth/MED）
4. `TILE_MATCH4`（8x8 を 4x4 x 4 に分割した完全一致参照）

選択は推定ビット最小化に基づく。`photo-like` 判定により MED 候補を制御し、回帰を抑制する。

モード決定の基本式:

- `m* = argmin_{m in M} R_hat(m)`
- `R_hat(m)` は mode type、参照オフセット、パレットサイズ、残差分布などから計算する近似レート。

### 2.4 lossy モード

lossy 経路では、品質パラメータに応じた量子化制御、クロマ処理（CfL 含む）、Band-group CDF を組み合わせる。  
本稿では「同一品質指標におけるサイズ・速度」の比較を重視する。

CfL の復号予測:

- `c_hat = ((a * (y - 128) + 32) >> 6) + b`

ここで `a` は Q6 係数、`b` はオフセット。エンコード時も同じ量子化後予測式で判定し、色ずれを抑える。

### 2.5 計算量と並列性

主要処理は画素数 `N` に対して概ね線形時間。復号側は探索を持たず、タイル/ブロック単位で並列化しやすい。
圧縮率改善は主にエンコーダ側のヒューリスティクスで吸収し、デコーダは単純さを維持する。

## 3. 実装上の要点

### 3.1 並列デコード中心設計

復号処理を独立度の高い単位に分解し、スレッド並列時の同期点を最小化する。  
これにより、単一画像でも一定の並列スケールが得られる。

### 3.2 段階的改善（Phase 9 系）

本稿で扱う改善系列は以下である。

1. `Base`（初期方式）
2. `9h`（lossless mode 推定選択）
3. `9j`（MED 追加）
4. `9j-2`（MED の photo-only ゲート）
5. `9k`（TileMatch4 追加）

この系列でアブレーションを行い、各施策の寄与を分離する。

## 4. 評価設計

### 4.1 データセット構成

評価は定性と定量を分離する。

#### A. 定性比較（3枚）

論文図として、以下を横並び比較する。

1. Anime 代表1枚（例: Artoria 系）
2. UI 代表1枚（タイル/文字を含む）
3. Photo 代表1枚（自然画像）

各図では、原画像・PNG/JPEG/HKN を同じ表示倍率で配置し、拡大クロップ（文字エッジ、輪郭、テクスチャ）を併記する。

#### B. 定量比較（30枚以上）

主張の裏付けは定量で行う。最低構成として以下を採用する。

1. UI: 10枚
2. Anime: 10枚
3. Photo/Natural: 10枚

可能であれば Game を追加し 40 枚構成へ拡張する。

### 4.2 比較対象

lossless 比較:

1. PNG（基準）
2. HKN lossless

lossy 比較:

1. JPEG
2. WebP（可能なら）
3. HKN lossy

### 4.3 指標

以下を報告する。

1. ファイルサイズ（bytes）
2. bpp
3. PSNR（必要に応じて SSIM 追加）
4. encode time（ms）
5. decode time（ms）

加えてカテゴリ別に平均、中央値、分位点（p10/p90）を示す。

### 4.4 再現プロトコル

本研究では `paper/repro/` のスクリプトを正とする。

```bash
python3 paper/repro/run_lossy_rd.py \
  --bin ./build/hakonyans \
  --qualities 30,50,70,90 \
  --runs 3 \
  --out-csv paper/results/lossy_rd.csv
```

```bash
bash paper/repro/run_lossless_snapshot.sh
```

## 5. 結果（記入テンプレ）

### 5.1 定性結果（図）

- 図1: Anime 比較（原画像/JPEG/PNG/HKN）
- 図2: UI 比較（原画像/JPEG/PNG/HKN）
- 図3: Photo 比較（原画像/JPEG/PNG/HKN）

観察ポイント:

1. エッジ周辺のにじみ
2. 平坦領域のバンディング
3. 微細テクスチャの保持

### 5.2 定量結果（表）

- 表1: カテゴリ別サイズ・PSNR・速度
- 表2: アブレーション（Base, 9h, 9j, 9j-2, 9k）

### 5.3 速度評価

デコード速度は平均値だけでなく分散（または標準偏差）も示し、安定性を評価する。

## 6. 考察

### 6.1 強み

1. 並列デコード性能と実装の単純性
2. エンコーダ最適化中心での圧縮率改善
3. UI/Anime/Photo での挙動差を吸収するモード適応

### 6.2 限界

1. コンテンツ依存性（カテゴリ間の改善幅差）
2. 一部モードでの探索コスト増
3. 比較対象との公平条件（同一品質合わせ）の難しさ

### 6.3 実運用への示唆

HakoNyans は「最高圧縮率競争」よりも、低遅延復号と扱いやすい実装を重視するユースケースに適する。

## 7. まとめ

本稿では、並列デコードを主軸とする HakoNyans の設計と段階的改善を示した。  
定性3枚・定量30枚以上の評価枠組みにより、視覚的説得力と統計的妥当性を両立する。  
今後は、評価セット拡張と比較条件の厳密化により、より一般化可能な結論を目指す。

## 付録A: 再現性情報

本文提出時点で以下を固定して記録する。

1. コミットハッシュ
2. 実行環境（CPU/OS/Compiler）
3. 実験コマンド
4. 結果ファイル（`paper/results/`）とチェックサム

## 付録B: ライセンスとデータ利用

定量評価に使う画像は、再配布可能ライセンスが明確なものを原則とする。  
著作権上の制約がある画像（例: 特定イラスト）は、定性例示のみで扱い、主統計からは分離する。
